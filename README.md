CG_SHOP_2025_2

- Βελτιστοποίηση Μη Αμβλυγώνιας Τριγωνοποίησης Επίπεδων Γράφων Ευθύγραμμων Τμημάτων (Planar StraightLine Graphs) με τη χρήση της βιβλιοθήκης CGAL.

- ΠΡΟΣΟΧΗ! Πριν την εκτέλεση του προγράμματος διαβάστε τις γραμμές 109-120.
===============================================================================================================================================
1. Περιγραφή: 
Η μείωση των αμβλυγώνιων τριγώνων γίνεται με τις εξής συναρτήσεις: 
void insert_projection(Custom_CDT& custom_cdt, const Face_handle& face, Polygon& polygon, Point_2& in_projection, Segment_2& opposide_edge);
void insert_midpoint(Custom_CDT& custom_cdt, const Face_handle& face, Polygon& polygon, Point_2& in_midpoint, Segment_2& longest_edge);
bool insert_adjecent_steiner(Custom_CDT& custom_cdt, const Face_handle& face, const Polygon& polygon, Point_2& adjecent_steiner);
bool insert_circumcenter(Custom_CDT& circumcenter_cdt, const Face_handle& face, const Polygon& polygon, Point_2& circumcenter_steiner);
void insert_centroid(Custom_CDT& centroid_cdt, const Face_handle& face, const Polygon& polygon, Point_2& centroid_steiner);

Γενικώς οι υλοποιήσεις των παραπάνω συναρτήσεων έχουν την φιλοσοφία να προσομιάζουμε (simulate) μια εισαγωγή steiner point, έχοντας ένα αντίγραφο της βασικής τριγωνοποίσης (cdt).

Η συνάρτηση start_the_flips() διατρέχει όλες τις ακμές του cdt βρίσκοντας τα 2 faces που χωρίζονται από αυτή της ακμή και από αυτά τα 2 faces παίρνει τα 4 σημεία τους (Points) και ελέγχει αρχικά αν τα 4 σημεία σχηματίζουν κυρτό πολύγωνο μέσω της συνάρτησης can_flip() ή οποία καλεί την is_convex() για να ελέγει την κυρτότητα του πολυγώνου. Η συνάρτηση can_flip() στο τέλος θα μας επιστρέψει γενικά αν μας συμφέρει (λιγότερες αμβλείες) να κάνουμε flip μια ακμή και όχι αν απλά γίνεται flip η ακμή.

Η συνάρτηση insert_circumcenter() εισάγει circumcenter point σε μια τριγωνοποίηση αν το circumcenter point είναι εντός boundary και αν η ακμή απέναντι από την κορυφή που δημιουργείται αμβλεία, δεν είναι ακμή constraint αλλά και το τετράπλευρο που σχηματίζουν τα σημεία του face με το face που μπήκε το circumcenter point αν είναι κυρτό.

Η συνάρτηση insert_centroid() εισάγει στο κέντρο του αμβληγώνιου τριγώνου το steiner point.

Η συνάρτηση insert_projection() διατρέχει τα faces του cdt, όταν βρεί αμβλυγώνιο τρίγωνο, βρίσκει σε ποιο point του face συμβαίνει αυτό αλλά και την ακμή απέναντι από την αμβλεία γωνία, ώστε να καλέσει την συνάρτηση line.projection() για να πάρουμε το σημείο προβολής της αμβλείας γωνίας με την απέναντι ευθεία.

Η συνάρτηση insert_midpoint() εισάγει στο μέσο της απέναντι πλευράς του obtuse vertex ένα steienr point.

Η συνάρτηση insert_adjecent_steiner() παίρνει ένα obtuse face και με αυξητικό τρόπο βρίσκει όλα τα γειτονικά τρίγωνα που είναι αμβλυγώνια και έχουν ώς μέρος τους αυτό το obtuse face που δέχτηκε στο όρισμα της. Ελέγχει αν το πολύγωνο που σχηματίζουν όλα αυτά τα obtuse faces είναι
κυρτό και εισάγει steiner point στο μέσο του πολυγώνου αυτού.

Η συνάρτηση insert_adjecent_steiner_local_search() χρησιμοποιείται μόνο για την μέθοδο της local search. Είναι πιο "έξυπνη" από την κλασσική 
insert_adjecent_steiner() καθώς σε κάθε βήμα της που προσθέτει obtuse γείτονες, ελέγχει και το κατά πόσο μείωσε τις αμβλείες αν προσέθετε steiner point στο μέσο αυτών των obtuse γειτόνων και κρατάει αυτό το υποσύνολο obtuse faces ππου μείωσαν περισσότερο τις αμβλείες στο cdt.

Όλες οι μέθοδοι, επειδή χρησιμοποιούν insert_no_flip(), μετά την εισαγωγή του εκάστοτε steiner point, κάνουν flips σε όλο το cdt με την custom συνάρτηση start_the_flips().

- Μέθοδος Local Search: 
Η μέθοδος αυτή ελέγχει για κάθε obtuse τρίγωνο όλες τις (5) μεθόδους εισαγωγής steiner και επιλέγει αυτή που μείωσε περισσότερο τα αμβλυγώνια μετά την εισαγωγή του steiner.

- Μέθοδος Simulated Annealing: 
Η μέθοδος αυτή, για κάθε obtuse τρίγωνο διαλέγει με τυχαίο τρόπο μια μέθοδο steiner και κάθε φορά που βρίσκει καλύτερη τριγωνοποίηση, την αποθηκεύει σαν best_cdt. Η μέθοδος αυτή τρέχει για L loops ή όταν η θερμοκρασία πλησιάσει το 0.
Επίσης αν υπάρξει βελτίωση της τριγωνοποίησης, η μέθοδος αυτή ξανατρέχει για L loops ή μέχρι η θερμοκρασίας να πλησιάσει το 0.
1) Κάθε φορά έχουμε ένα αντίγραφο cdt (simulate_cdt) του best_cdt και του εισάγουμε steiner ώστε να δούμε βελτίωση στην μείωση των αμβλειών.
2) Στην περίπτωση που δεν μπορεί να επιλεγεί το circumcenter κάνουμε skip το συγκεκριμένο obtuse face.
3) Στην περίπτωση που δεν μπορεί να επιλεγεί το steiner για τα γειτονικά τρίγωνα, επιλέγεται η μέθοδος της προβολής (projection).
4) Την μέθοδο αυτή την αφήνουμε για 180 iterations στην αρχή χωρίς να πειράξουμε την θερμοκρασία με σκοπό να φτάσει σε τοπικό ελάχιστο.
'Υστερα αυξάνουμε την θερμοκρασία με σκοπό να φύγουμε απο το τοπικό ελάχιστο που πέσαμε, έτσι ώστε να αυξηθούν οι πιθανότητες να επιλέγονται κακά steiner. Το πρόγραμμα δέχεται περισσότερα από 1 κακά steiner μέχρι να δεί βελτίωση, η παράμετρος αυτή ονομάζεται batch size και ορίζεται από τον χρήστη στο input json file.
5) Εφόσον εισαχθούν ακριβώς batch size κακά steiner points, το simulate_cdt ξαναγίνεται best_cdt ώστε να αρχίσουμε νέο κύκλο εισαγωγής "κακών" steiner points, με σκοπό να δούμε βελτίωση στην μείωση των αμβλειών.
Αυτό το "restart" από simulated cdt σε best_cdt γίνεται είτε όταν έχουμε εισάγει batch_size steiners και δεν είχαμε βελτίωση, είτε αν αυτές οι εισαγωγές κακών steiner μας χάλασαν την τριγωνοποίηση (αντί να μας την βελτιώσει) κατά 3 ή και περισσότερες αμβλείες.
6) Επίσης με σκοπό το πρόγραμμα να επαναφέρει την simulate τριγωνοποίηση σε best_cdt τριγωνοποίηση επειδή η τριγωνοποίηση χειροτέρεψε κατά 3 ή περισσότερες αμβλείες, τότε ορίζουμε το ΔΕ = 0.000001 έτσι ώστε στον υπολογισμό της πιθανότητας (e^(-∆E / T)) που δέχεται τα κακά steiner, νε είναι ίση με 1 που σημαίνει ότι θα μπούμε στην περίπτωση που δεχόμαστε κακό steiner αλλά θα ελεγχθεί ότι η simulated τριγωνοποίηση χειροτέρεψε κατά πολύ (3 steiner) και θα την επαναφέρει στην best_cdt μορφή ώστε να ξεκινήσει νέο κύκλο εισαγωγής steiner.
7) Η θερμοκρασία δεν μειώνεται γραμικά, αλλά πολλαπλασιαστικά κατά Τ*0.99 έτσι ώστε να παραμένουμε περισσότερο χρόνο ψηλά στην "κοιλάδα" έτσι ώστε να μπορούμε να μεταφρθούμε σε γειτονικά ελάχιστα.
8) Τα α και β που επιλέχθηκαν είναι χαμηλά (α = 2.4 και β = 0.2) και αυτό διότι θέλουμε το ΔΕ της πιθανότητας επιλογής κακού steiner (e^(-∆E / T)) να είναι χαμηλό, έτσι ώστε όταν η θερμοκρασία είναι υψηλή, να υπάρχει μεγάλη πιθανότητα επιλογής κακού steiner ώστε να φύγουμε από τοπικά ελάχιστα.

- Μέθοδος Ant Colony:
Στην μέθοδο αυτή, δημιουργήθηκε μια κλάση ant, ώστε κάθε τέτοιο ant σε κάθε κύκλο να κρατάει όλες τις απαραίτητες πληροφορίες για το cdt που του εισήγαγε steiner point που κάποιες από αυτές είναι:
1) Set από faces τα οποία επηρέασε μετά από εισαγωγή steiner, ώστε μετά να συγκρίνει αυτό το set μετα τα set των άλλων μυρμηγκιών για ύπαρξη conflict.
2) Το cdt στο οποίο εισήγαγε steiner point.
3) Την μέθοδο steiner που χρησιμοποίησε.
4) Booleans μεταβλητές αν μείωσε τις αμβλείες και αν είναι μυρμήγκι που έπεσε σε conflict.

Μερική περιγραφή της μεθόδου Ant Colony:
Κάθε μυρμήγκι:
       Σε κάθε κύκλο "κουβαλάει" την καλυτερη τριγωνοποίηση (best_cdt) του προηγούμενου κύκλου.
       Βάζει ένα steiner point σε ένα τυχαίο obtuse face, με βάση τα heuristics που δώθηκαν.
Στο τέλος κάθε κύκλου κρατάμε σε ξεχωριστό vector (ant_reduce_obtuses_vector) τα μυρμήγκια που πέτυχαν μείωση αμβλυγωνίων με την εισαγωγή του steiner point.
Από αυτά, ελέγχουμε αν μεταξύ τους υπάρχει conflict και αν υπάρχει, κρατάμε το μυρμήγκι με την χαμηλότερη ενέργεια στο cdt που κουβαλάει και αυτά τα τελικά μυρμήγκια τα βάζουμε σε άλλον vector (ant_last_winners_vector).
Κάνουμε merge τις λύσεις των μυρμηγκιών του ant_last_winners_vector και ενημερώνουμε το νέο best_cdt.
Γίνεται ενημέρωση φερομόνης κτλπ.

===============================================================================================================================================

2. Οργάνωση Φακέλων: 
CG_SHOP_2025_3: 
/tests/challenge_instances: 
Τα .json instances του διαγωνισμού. 

best_instances:
Φάκελος που περιέχει ξεχωριστά σε αρχεία md τα αποτελέσαμτα των instances.
Υπάρχουν ξεχωριστά αρχεία md, αναλόγως και το όνομα του json αρχείου.
π.χ υπάρχει ξεχωριστό αρχείο md για όλα τα ortho instances

/includes/utils: 
a. Custom_Constrained_Delaunay_triangulation_2.h  
b. functions.h : οι δηλώσεις των συναρτήσεων.
c. functions_task1.h : Οι ορισμοί των συναρτήσεων που υλοποιήσαμε στην 1η εργασία.
d. ant.h : Ο ορισμός της κλάσης των μυρμηγκιών που χρησιμοποιούνται εφόσον επιλεχθεί η μέθοδος Ant Colony.
e. libraries.h : Βιβλιοθήκες της CGAL, Standard c++ αλλά και custom ώστε να τις κάνουν include τα αρχεία που τις χρειάζονται.
    Περιέχει και enumeration της κάθε μεθόδου steiner που χρειαζόμαστε στην μέθοδο Ant Colony.
f. extra_graphics.h : γραφικά για την εκτύπωση του CDT με χρωματισμό των τριγώνων που είναι αμβλυγώνια, των κορυφών όπου υπάρχει     αμβλεία γωνία, αλλά και εμφάνιση των συντεταγμένων κάθε κορυφής.


- CMakeLists.txt: 
Το αρχείο που χρειάζεται για την εισαγωγή των κατάλληλων βιβλιοθηκών (CGAL, Boost, γραφικών) ώστε να παράγουμε το επιθυμητό εκτελέσιμο.
Δεν πρέπει να δημιουργηθεί νέο!

- functions.cpp : οι υλοποιήσεις των συναρτήσεων που δημιουργήσαμε ώστε να εκπονήσουμε την εργασία.

- ant.cpp : Η υλοποίηση της κλάσης των μυρμηγκιών που χρησιμοποιούνται εφόσον επιλεχθεί η μέθοδος Ant Colony.

- project.cpp: 
Το αρχείο μας με την main function που αντλεί δεδομένα από ένα .json αρχείο με δεδομένα για έναν γράφο πάνω στον οποίο δημιουργούμε την τριγωνοποίηση Delaunay, και την βελτιστοποιούμε μέσω προκαθορισμένων επιλογών από το αρχείο json ως εξής:
a. Εάν έχει ορισθεί ως false η παράμετρος delauney στο json αρχείο, εκτελείται ο κώδικας της 1ης εργασίας και παράγεται ένα CDT. 
Στην συνέχεια το CDT που είχε ως αποτέλεσμα η εκτέλεση της πρώτης εργασίας, γίνεται input σε μια από τις 3 μεθόδους (Local Search, Simulated Annealing, Ant Colony Optimization) που έχουν επιλεγεί
στο input.json file.
b. Αφού τρέξει η μια από τις 3 μεθόδους, παίρνουμε το αποτέλεσμα και τα στοιχεία της τριγωνοποίησης μπαίνουν στο utput.json file.

- functions_task1.cpp : Οι υλοποιήσεις των συναρτήσεων που υλοποιήσαμε στην 1η εργασία, οι οποίες δύναται να εκτελεστούν εφόσον δοθεί ως input "delauney: false".

- .git Ο φάκελος με τις πληροφορίες για push, commit etc στο Github Repository
===============================================================================================================================================
ΣΗΜΕΙΩΣΗ: 
Οι παρακάτω εντολές πρέπει να βρίσκονται στο αρχείο .bashrc: 
- export LD_LIBRARY_PATH=/usr/lib/x86_64-linux-gnu:$LD_LIBRARY_PATH 
- export DISPLAY=:0 export BOOST_ROOT= "το path που βρίσκεται ο φάκελος boost_1_80_0" 
- export CGAL_ROOT="το path που βρίσκεται ο φάκελος της βιβλιοθήκης CGAL-5.6.1" 
Χρησιμοποιήθηκε η έκδοση 1_80_0 της Boost στην υπολοποίησή μας.

3. Οδηγίες Μεταγλώττισης & Εκτέλεσης στο terminal: 
Step 1: /path/to/program 
Step 2: cmake -DCGAL_DIR=/usr/lib/CGAL 
Step 3: make 
Step 4: ./opt_triangulation -i tests/challenge_instances/ortho_10_d2723dcc.instance.json -o solution_output.json

- ΠΡΟΣΟΧΗ! Δεν πρέπει να τρέξει η εντολή cgal_create_CMakeLists -s, το CMakeLists.txt στον υπάρχον φάκελο είναι το κατάλληλο και περιέχει τα κατάλληλα includes βιβλιοθηκών για το υπάρχον πρόγραμμα.

- ΠΡΟΣΟΧΗ! Τα input json files για την μέθοδο Simulated Annealing περιέχουν μια επιπλέον παράμετρο, το batch size το οποίο ο χρήστης δηλώνει
τον αριθμό των "κακών" steiner points που δέχονται στην τριγωνοποίηση τους, μέχρι να δούμε βελτίωση στην τριγωνοποίηση.

Στον κεντρικό φάκελο υπάρχει το αρχείο update_json_files.py όπου στην γραμμή 32 αυτού του αρχείου python μπορείτε να αλλάξετε σε όλα τα instances του διαγωνισμού, ποιά μέθοδο θέλετε να χρησιμοποιήσετε (local, sa, ant, auto).
Το python αρχείο ενημερώνεται με την την εντολή στο terminal python3 update_json_files.py, εφόσον είστε στον φάκελο CG_SHOP_2025_3.
===============================================================================================================================================

4. Το πρόγραμμα τρέχει με μια εντολή στο terminal τύπου :
./opt_triangulation –i /path/to/input.json –o /path/to/output.json –preselected_params 
όπως ακριβώς ζητήθηκε στην εκφώνηση της εργασίας. Τα input json files περιέχουν όλες τις πληροφορίες για να τρέξει το πρόγραμμα.
Στον φάκελο tests υπάρχουν test cases που μπορείτε να δώσετε στο terminal.
==============================================================================================================================================
5. Στοιχεία Φοιτητών: 
ΠΑΠΑΔΗΜΟΠΟΥΛΟΣ ΜΙΧΑΗΛ-ΑΓΓΕΛΟΣ sdi2000163
ΑΝΑΣΤΑΣΟΠΟΥΛΟΣ ΑΝΔΡΕΑΣ sdi1900009
===============================================================================================================================================
6) 
- Η επιλογή των τιμών α και β στο Simulated Annealing είναι 2.4 και 0.2 αντίστοιχα, έτσι ώστε το ΔΕ να είναι χαμηλό ώστε να έχουμε περισσότερες πιθανότητες να διαλέξουμε κακά steiner την ώρα που έχουμε πέσει σε τοπικό ελάχιστο και θέλουμε να φύγουμε από αυτό για να οδηγηθούμε σε καλύτερο τοπικό ελάχιστο ή και ελάχιστο.
Η επιλογή του L στο SA είναι στα 900 loops γιατί αυξομειώνουμε την θερμκρασία μέχρι εκείνη την στιγμή, με σκοπό να φύγουμε από τοπικό ελάχιστο.

- Η επιλογή του L = 150 στο ant colony είναι γιατί από εκεί και πέρα δεν βρήκαμε καμία βελτίωση σε κανένα test.
Επίσης η επιλογή για n/2 ants, έχει σκοπό να μπορέσουν σε έναν κύκλο πολλά μυρμήγκια να διαλέξουν και το ίδιο obtuse face αλλά με διαφορετική μέθοδο, με σκοπό να αυξήσουμε (αν όχι να εξαντλήσουμε) τους συνδυασμούς μεθόδων με βάση το κάθε obtuse face, ώστε να φτάσουμε σε ελάχιστο για την συγκεκριμένη μέθοδο.
Όσο για το λ το το ορίσαμε χαμηλά στο 0.2 και το ψ = 2.0, γιατί θέλουμε τα μυρμήγκια να θυμούνται την απόδοση της κάθε μεθόδου για περισσότερο χρόνο, βλέποντας έτσι και σταθερά βέλτιστη λύση στο πρόγραμμά μας σε σχέση με μεγαλύτερες τιμές.

- Η επιλογή L = 150 στην μέθοδο είναι τυπική, καθώς σταματάει αν μετά από έναν κύκλο από 150 loops δεν υπήρχε βελτίωση στην τριγωνοποίηση ή αν μηδενιστουν οι αμβλείες.
=================================================================================================================================

## Παραδοχές εργασίας 3.
- Το πρόγραμμα από το τύπο εισόδου που αναγνωρίζει, επιλέγει το κατάλληλο υποσύνολο από μεθόδους steiner με βάση τα αποτελέσματα των πειραμάτων που είχαμε.
- Το τυχαιοποιημένο σημείο που επιλέχθηκε να εισάγεται σε τυχαίο αμβλυγώνιο τρίγωνο μόλις η τριγωνοποίηση έφτασε σε τοπικό ελάχιστο, είναι ένα τυχαίο σημείο
με κανονική κατανομή (Gauss) γύρω από το βαρύκεντρο ενός αμβλυγωνίου τριγώνου.
- Το τυχαίο σημείο επιλέγεται μέχρι και σε απόσταση ίση με την μικρότερη ακτίνα από το βαρύκεντρο προς κάποια ακμή του αμβλυγωνίου τριγώνου. Αυτό σημαίνει ότι το τυχαίο σημείο μπορεί να βρίσκεται και σε "μεγάλη" απόσταση από το βαρύκεντρο που μας επιτρέπει να δοκιμάζονται πολλά σημεία εντός του τριγώνου γιατί μπορεί να εκταθεί σε "μεγάλη" απόσταση.
- Η φιλοσοφία του περισσότερο βασίζεται στο ότι μετά την εισαγωγή του τυχαίου σημείου, οι αμβλείες θα μειωθούν μετά από flips ή και συνδυασμό εισαγωγής τυχαίου σημείου και κάποιας προϋπάρχουσας μεθόδου steiner (projection, midpoint etc) + flips.

1) Local Search
- Στην μέθοδο Local Search μόλις για έναν κύκλο παρατηρηθεί πως δεν υπάρχει βελτίωση της τριγωνοποίησης, τότε ενεργοποιείται η
εισαγωγή τυχαίου σημείου και υπάρχουν 2 ενδεχόμενα να μειωθούν οι αμβλείες μετά την εισαγωγή του τυχαίου σημείου:
(α) Να μειωθούν οι αμβλείες με flips
(β) Να μειωθούν οι αμβλείες προσθέτοντας και ένα steiner point από τα προϋπάρχοντα steiner points (projection, midpoint etc) + flips.

2) Simulated Annealing
- Στην μέθοδο Simulated Annealing το τυχαίο σημείο ενεργοποιείται ώστε να εισαχθεί μετά από L/1.5 loops, διότι έχουμε βάλει έναν υψηλό αριθμό από loops (L)
στο Simulated annealing ώστε μετά από ένα σημείο και μετά που δεν παρατηρείται βελτίωση, να προσπαθούμε με εισαγωγή του τυχαίου σημείου να μειώσουμε τις αμβλείες.
- Όταν εισαχθεί το τυχαίο σημείο ελέγχεται αν από μόνο του βελτίωσε (πάντα με συνδυασμό flips) τον αριθμό των αμβλειών ή μειωθούν οι αμβλείες με εισαγωγή μέχρι και 6 (5+1) προϋπαρχόντων steiner points που δεν βελτιώνουν την τριγωνοποίηση άμεσα, αλλά μπορούν μακροπρόθεσμα.

3) Ants Colony
- Στην μέθοδο Ants Colony, την πρώτη φορά, το τυχαιοποιημένο σημείο εισάγεται μετά από 15 loops χωρίς βελτίωση της τριγωνοποίησης με σκοπό να βελτιώση την κατάσταση.
- Όπως και στις προηγούμενες περιπτώσεις, το τυχαιοποιημένο σημείο μπορεί να βελτιώσει την τριγωνοποίηση στις 2 περιπτώσεις (άμσεη βελτίωση, ή βελτίωση με εισαγωγή επιπλέον μιας μεθόδου από τα προϋπάρχοντα steiner points).
- Από την στιγμή που εισαχθεί το τυχαίο σημείο, το πρόγραμμα αφήνει τα μυρμήγκια για 10 loops μήπως βελτιώσουν την κατάσταση. Μετά επαναλαμβάνει την εισαγωγή του τυχαίου σημείου κάθε 10 loops που δεν υπάρχει βελτίωση.

Παρατήρηση:
- Πάντοτε ο Simualted Annealing αλγόριθμος είναι καλύτερος σε όλα τα instances του διαγωνισμού.
Τρέχοντας όλα τα υποσύνολα από steiner points, παρατηρήθηκε ότι τα καλύτερα αποτελέσματα προήλθαν είτε χρησιμοποιόντας μόνο την μέθοδο projection, είτε και τις 5 γνωστές μεθόδους (projection, midpoint, polygon, centroid, circumcenter).
- Στο να μηδενίζονται τα instances επικράτησαν και οι 5 μέθοδοι, γιατί σε περιπτώσεις τοπικού ελάχίτου, είχαν εναλλακτικές επιλογές από steiner points.
